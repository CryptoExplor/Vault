<!DOCTYPE html>
<html lang="en" class="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Note Manager</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/lib/marked.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.12.1/dist/ethers.umd.min.js"></script>

  <script>
    const THEME_KEY = 'theme_preference';
    const NOTES_KEY = 'notes_content';
    let walletAddress = null;
    let allTags = new Set();
    let selectedTags = [];
    let searchTimeout;

    // Custom Alert/Toast
    function showToast(message, type = 'info') {
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toast-message');
      toastMessage.textContent = message;
      toast.className = 'toast fixed bottom-4 right-4 p-4 rounded-lg shadow-lg z-50 transition-transform transform translate-y-20';

      if (type === 'success') {
        toast.classList.add('bg-green-500', 'text-white');
      } else if (type === 'error') {
        toast.classList.add('bg-red-500', 'text-white');
      } else {
        toast.classList.add('bg-gray-800', 'text-white');
      }

      setTimeout(() => {
        toast.classList.add('translate-y-0');
      }, 10);
      
      setTimeout(() => {
        toast.classList.remove('translate-y-0');
        setTimeout(() => {
            toast.className = 'toast fixed bottom-4 right-4 p-4 rounded-lg shadow-lg z-50 transition-transform transform translate-y-20';
        }, 500);
      }, 3000);
    }
    
    // Custom Modal for confirmations (replacing window.confirm)
    function showModal(message, onConfirm) {
      const modal = document.getElementById('confirmation-modal');
      const modalMessage = document.getElementById('modal-message');
      const confirmButton = document.getElementById('confirm-button');
      const cancelButton = document.getElementById('cancel-button');

      modalMessage.textContent = message;
      modal.classList.remove('hidden');

      confirmButton.onclick = () => {
        modal.classList.add('hidden');
        onConfirm(true);
      };
      cancelButton.onclick = () => {
        modal.classList.add('hidden');
        onConfirm(false);
      };
    }

    // Encryption/Decryption Functions
    // Use the wallet address as the key for a simple XOR encryption.
    function encrypt(text, key) {
        if (!key) return text;
        const keyChars = key.split('').map(c => c.charCodeAt(0));
        let encrypted = '';
        for (let i = 0; i < text.length; i++) {
            encrypted += String.fromCharCode(text.charCodeAt(i) ^ keyChars[i % keyChars.length]);
        }
        return btoa(encrypted);
    }

    function decrypt(encryptedText, key) {
        if (!key) return encryptedText;
        try {
            const keyChars = key.split('').map(c => c.charCodeAt(0));
            const decoded = atob(encryptedText);
            let decrypted = '';
            for (let i = 0; i < decoded.length; i++) {
                decrypted += String.fromCharCode(decoded.charCodeAt(i) ^ keyChars[i % keyChars.length]);
            }
            return decrypted;
        } catch (e) {
            return encryptedText; // Fallback for unencrypted text
        }
    }

    // Wallet Connection Logic
    window.connectWallet = async () => {
        if (typeof window.ethereum === 'undefined') {
            showToast('MetaMask is not installed. Please install it to use this feature.', 'error');
            return;
        }
        try {
            const provider = new ethers.BrowserProvider(window.ethereum);
            await provider.send("eth_requestAccounts", []);
            const signer = await provider.getSigner();
            walletAddress = await signer.getAddress();
            document.getElementById('wallet-status').textContent = `Wallet Connected: ${walletAddress.substring(0, 6)}...${walletAddress.substring(walletAddress.length - 4)}`;
            document.getElementById('connect-wallet-btn').classList.add('hidden');
            showToast('Wallet connected successfully!', 'success');
            updateAllTags();
            updateNoteDisplay();
        } catch (error) {
            console.error(error);
            showToast('Failed to connect wallet.', 'error');
        }
    };

    // Note Rendering and Management
    function updateNoteDisplay(searchTerm = '') {
        const notesContainer = document.getElementById('notes-container');
        const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]').map(note => ({
            ...note,
            content: decrypt(note.content, walletAddress)
        }));
        
        // Filter notes by search term and selected tags
        const filteredNotes = notes.filter(note => {
            const matchesSearch = searchTerm === '' || 
                                  note.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
                                  note.content.toLowerCase().includes(searchTerm.toLowerCase());
            const matchesTags = selectedTags.length === 0 || 
                                selectedTags.every(tag => note.tags.includes(tag));
            return matchesSearch && matchesTags;
        });

        // Sort notes: Pinned first, then by date
        filteredNotes.sort((a, b) => (b.isPinned - a.isPinned) || new Date(b.date) - new Date(a.date));

        notesContainer.innerHTML = '';
        if (filteredNotes.length === 0) {
            notesContainer.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-center">No matching notes found.</p>';
        } else {
            filteredNotes.forEach((note, index) => {
                const noteDiv = document.createElement('div');
                noteDiv.classList.add('note-card', 'bg-white', 'dark:bg-gray-700', 'p-4', 'rounded-lg', 'shadow-md', 'border-l-4', 'border-purple-500', 'dark:border-purple-400', 'hover:shadow-lg', 'transition-shadow', 'duration-200', 'cursor-grab', 'relative');
                if (note.isPinned) {
                    noteDiv.classList.add('pinned-note', 'border-yellow-500', 'dark:border-yellow-400', 'ring-2', 'ring-yellow-500');
                }
                noteDiv.setAttribute('data-index', index);
                
                const title = document.createElement('h3');
                title.classList.add('text-xl', 'font-bold', 'mb-2', 'text-gray-900', 'dark:text-white');
                title.textContent = note.title;

                const content = document.createElement('div');
                content.classList.add('text-gray-700', 'dark:text-gray-300', 'mb-4', 'break-words', 'prose', 'prose-sm', 'dark:prose-invert', 'max-w-none');
                content.innerHTML = marked.parse(note.content);

                const tags = document.createElement('div');
                tags.classList.add('flex', 'flex-wrap', 'gap-1', 'mb-2');
                note.tags.forEach(tag => {
                    tags.innerHTML += `<span class="bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200 text-xs font-semibold px-2.5 py-0.5 rounded-full">${tag}</span>`;
                });

                const footer = document.createElement('div');
                footer.classList.add('flex', 'justify-between', 'items-center', 'text-sm', 'text-gray-500', 'dark:text-gray-400');
                footer.innerHTML = `
                  <span>${note.date}</span>
                  <div class="space-x-2">
                    <button onclick="togglePinNote('${note.id}')" class="text-gray-500 hover:text-yellow-500 transition-colors ${note.isPinned ? 'text-yellow-500' : ''}"><i class="fas fa-thumbtack"></i></button>
                    <button onclick="editNote('${note.id}')" class="text-blue-500 hover:text-blue-600 dark:hover:text-blue-400 transition-colors"><i class="fas fa-edit"></i></button>
                    <button onclick="deleteNote('${note.id}')" class="text-red-500 hover:text-red-600 dark:hover:text-red-400 transition-colors"><i class="fas fa-trash-alt"></i></button>
                    <button onclick="exportNoteAsMarkdown('${note.id}')" class="text-gray-500 hover:text-purple-500 transition-colors"><i class="fas fa-file-export"></i></button>
                    <button onclick="showVersionHistory('${note.id}')" class="text-gray-500 hover:text-gray-600 transition-colors"><i class="fas fa-history"></i></button>
                  </div>
                `;

                noteDiv.appendChild(title);
                noteDiv.appendChild(tags);
                noteDiv.appendChild(content);
                noteDiv.appendChild(footer);
                notesContainer.appendChild(noteDiv);
            });
        }
        setupSortable();
    }
    
    // Update the master tag list for autocomplete
    function updateAllTags() {
        const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]').map(note => ({
            ...note,
            content: decrypt(note.content, walletAddress)
        }));
        allTags = new Set();
        notes.forEach(note => {
            if (note.tags) {
                note.tags.forEach(tag => allTags.add(tag));
            }
        });
        updateTagFilterDropdown();
    }

    function updateTagFilterDropdown() {
        const filterDropdown = document.getElementById('filter-tags');
        filterDropdown.innerHTML = `<option value="">All Tags</option>`;
        allTags.forEach(tag => {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = tag;
            filterDropdown.appendChild(option);
        });
    }

    // Existing functions
    window.addNote = () => {
        const titleInput = document.getElementById('new-note-title');
        const contentInput = document.getElementById('new-note-content');
        const tagsInput = document.getElementById('new-note-tags');
        const title = titleInput.value.trim();
        const content = contentInput.value.trim();
        const tags = tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
        
        if (!walletAddress) {
            showToast('Please connect your wallet first.', 'error');
            return;
        }

        if (title === '' || content === '') {
            showToast('Title and content cannot be empty.', 'error');
            return;
        }

        const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]');
        notes.unshift({
            id: crypto.randomUUID(),
            title,
            content: encrypt(content, walletAddress),
            tags,
            isPinned: false,
            history: [],
            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })
        });
        localStorage.setItem(NOTES_KEY, JSON.stringify(notes));
        updateAllTags();
        updateNoteDisplay();
        titleInput.value = '';
        contentInput.value = '';
        tagsInput.value = '';
        showToast('Note added!', 'success');
    };

    window.editNote = (id) => {
        if (!walletAddress) {
            showToast('Please connect your wallet first.', 'error');
            return;
        }

        const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]');
        const noteIndex = notes.findIndex(note => note.id === id);
        if (noteIndex === -1) return;
        
        const note = notes[noteIndex];
        const content = decrypt(note.content, walletAddress);

        document.getElementById('edit-title').value = note.title;
        document.getElementById('edit-content').value = content;
        document.getElementById('edit-tags').value = note.tags.join(', ');
        document.getElementById('edit-note-modal').classList.remove('hidden');

        document.getElementById('save-edit-btn').onclick = () => {
            const newTitle = document.getElementById('edit-title').value.trim();
            const newContent = document.getElementById('edit-content').value.trim();
            const newTags = document.getElementById('edit-tags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');

            if (newTitle === '' || newContent === '') {
                showToast('Title and content cannot be empty.', 'error');
                return;
            }
            
            // Save version history
            if (content !== newContent) {
                note.history.unshift({
                    content: note.content,
                    date: new Date().toISOString()
                });
                if (note.history.length > 5) {
                    note.history.pop();
                }
            }

            note.title = newTitle;
            note.content = encrypt(newContent, walletAddress);
            note.tags = newTags;

            localStorage.setItem(NOTES_KEY, JSON.stringify(notes));
            updateAllTags();
            updateNoteDisplay();
            document.getElementById('edit-note-modal').classList.add('hidden');
            showToast('Note updated!', 'success');
        };
    };

    window.deleteNote = (id) => {
        showModal('Are you sure you want to delete this note?', (confirmed) => {
          if (confirmed) {
              const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]');
              const updatedNotes = notes.filter(note => note.id !== id);
              localStorage.setItem(NOTES_KEY, JSON.stringify(updatedNotes));
              updateAllTags();
              updateNoteDisplay();
              showToast('Note deleted!', 'success');
          }
        });
    };
    
    window.togglePinNote = (id) => {
        const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]');
        const noteIndex = notes.findIndex(note => note.id === id);
        if (noteIndex === -1) return;

        notes[noteIndex].isPinned = !notes[noteIndex].isPinned;
        localStorage.setItem(NOTES_KEY, JSON.stringify(notes));
        updateNoteDisplay();
    };

    window.exportNoteAsMarkdown = (id) => {
        if (!walletAddress) {
            showToast('Please connect your wallet first.', 'error');
            return;
        }

        const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]');
        const note = notes.find(n => n.id === id);
        if (!note) {
            showToast('Note not found.', 'error');
            return;
        }

        const content = decrypt(note.content, walletAddress);
        const fileName = `${note.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.md`;
        const blob = new Blob([`# ${note.title}\n\n${content}\n\n---\nTags: ${note.tags.join(', ')}\nDate: ${note.date}`], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Note exported!', 'success');
    };

    window.showVersionHistory = (id) => {
        const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]');
        const note = notes.find(n => n.id === id);
        if (!note || !note.history || note.history.length === 0) {
            showToast('No version history for this note.', 'info');
            return;
        }

        const modal = document.getElementById('history-modal');
        const list = document.getElementById('history-list');
        list.innerHTML = '';
        note.history.forEach((version, index) => {
            const li = document.createElement('li');
            li.classList.add('p-4', 'rounded-lg', 'bg-gray-100', 'dark:bg-gray-700', 'flex', 'justify-between', 'items-center', 'mb-2');
            li.innerHTML = `
                <span class="text-sm">Version saved on ${new Date(version.date).toLocaleString()}</span>
                <button onclick="restoreVersion('${id}', ${index})" class="px-3 py-1 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition-colors">Restore</button>
            `;
            list.appendChild(li);
        });
        modal.classList.remove('hidden');
    };
    
    window.restoreVersion = (noteId, versionIndex) => {
        const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]');
        const note = notes.find(n => n.id === noteId);
        if (!note) return;

        const oldContent = note.content;
        const newContent = note.history[versionIndex].content;
        
        note.history.unshift({
            content: oldContent,
            date: new Date().toISOString()
        });
        if (note.history.length > 5) {
            note.history.pop();
        }

        note.content = newContent;
        localStorage.setItem(NOTES_KEY, JSON.stringify(notes));
        updateNoteDisplay();
        document.getElementById('history-modal').classList.add('hidden');
        showToast('Version restored!', 'success');
    };

    function setupSortable() {
        const notesContainer = document.getElementById('notes-container');
        if (notesContainer) {
            new Sortable(notesContainer, {
                animation: 150,
                onEnd: (evt) => {
                    const notes = JSON.parse(localStorage.getItem(NOTES_KEY) || '[]');
                    const [movedItem] = notes.splice(evt.oldIndex, 1);
                    notes.splice(evt.newIndex, 0, movedItem);
                    localStorage.setItem(NOTES_KEY, JSON.stringify(notes));
                    updateNoteDisplay();
                }
            });
        }
    }

    // Check for theme on load
    window.addEventListener('load', () => {
      const savedTheme = localStorage.getItem(THEME_KEY);
      if (savedTheme) {
        document.documentElement.classList.remove('light', 'dark');
        document.documentElement.classList.add(savedTheme);
      }
      
      updateAllTags();
      updateNoteDisplay();
    });

  </script>
  
  <style>
    body {
      font-family: 'Inter', sans-serif;
      transition: background-color 0.3s ease;
      background-color: #f3f4f6;
    }
    .dark body {
      background-color: #111827;
      color: #e5e7eb;
    }
    .note-card {
        cursor: grab;
        transition: box-shadow 0.2s, transform 0.2s;
    }
    .note-card:active {
        cursor: grabbing;
    }
    .prose a {
      color: #3b82f6;
    }
    .prose h1, .prose h2, .prose h3 {
      font-weight: bold;
    }
    .ghost {
        opacity: 0.5;
    }
    .sortable-chosen {
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        transform: rotate(2deg) scale(1.05);
    }
    .pinned-note {
        border-left-color: #f59e0b;
        border-left-width: 6px;
    }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen p-4">

  <!-- Main Container -->
  <div class="max-w-4xl mx-auto py-8">
    <header class="text-center mb-10">
      <h1 class="text-4xl font-extrabold text-purple-600 dark:text-purple-400 mb-2">Note Manager</h1>
      <p class="text-gray-500 dark:text-gray-400">Your notes, stored locally and in the cloud.</p>
    </header>

    <div id="user-info" class="text-center text-sm text-gray-500 dark:text-gray-400 mb-4 flex flex-col items-center gap-2">
        <button id="connect-wallet-btn" onclick="connectWallet()" class="px-6 py-2 bg-purple-600 text-white font-bold rounded-lg hover:bg-purple-700 transition-colors"><i class="fas fa-wallet mr-2"></i>Connect Wallet</button>
        <span id="wallet-status">Wallet not connected.</span>
    </div>

    <!-- Note Input Section -->
    <div class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-xl mb-8">
      <h2 class="text-2xl font-bold mb-4 text-purple-600 dark:text-purple-400">Add New Note</h2>
      <input type="text" id="new-note-title" placeholder="Note Title" class="w-full px-4 py-3 mb-4 rounded-lg bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500">
      <textarea id="new-note-content" placeholder="Write your note here... (supports Markdown)" rows="5" class="w-full px-4 py-3 mb-4 rounded-lg bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500"></textarea>
      <input type="text" id="new-note-tags" placeholder="Tags (e.g., work, ideas)" class="w-full px-4 py-3 mb-4 rounded-lg bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500">
      <button onclick="addNote()" class="w-full py-3 bg-purple-600 text-white font-bold rounded-lg hover:bg-purple-700 transition-colors">Add Note</button>
    </div>

    <!-- Notes Display Section -->
    <div class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-xl">
      <div class="flex justify-between items-center mb-6 flex-wrap gap-4">
        <h2 class="text-2xl font-bold text-purple-600 dark:text-purple-400">My Notes</h2>
        <div class="flex space-x-2">
            <select id="filter-tags" onchange="selectedTags = this.value ? [this.value] : []; updateNoteDisplay()" class="px-4 py-2 rounded-full bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600">
                <option value="">All Tags</option>
            </select>
            <input type="text" id="search-input" onkeyup="clearTimeout(searchTimeout); searchTimeout = setTimeout(() => updateNoteDisplay(this.value), 300);" placeholder="Search notes..." class="px-4 py-2 rounded-full bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500">
        </div>
      </div>
      <div id="notes-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Notes will be dynamically inserted here -->
      </div>
    </div>
  </div>

  <!-- Toast/Alert component -->
  <div id="toast" class="toast fixed bottom-4 right-4 p-4 rounded-lg shadow-lg z-50 transition-transform transform translate-y-20">
    <span id="toast-message"></span>
  </div>

  <!-- Confirmation Modal -->
  <div id="confirmation-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
    <div class="bg-white dark:bg-gray-800 p-8 rounded-xl shadow-2xl text-center w-96">
        <h3 class="text-xl font-bold mb-4">Confirmation</h3>
        <p id="modal-message" class="text-gray-700 dark:text-gray-300 mb-6"></p>
        <div class="flex justify-around">
            <button id="confirm-button" class="px-6 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600">Yes</button>
            <button id="cancel-button" class="px-6 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400">No</button>
        </div>
    </div>
  </div>
  
  <!-- Edit Note Modal -->
  <div id="edit-note-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
    <div class="bg-white dark:bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-2xl">
      <h2 class="text-2xl font-bold mb-4 text-purple-600 dark:text-purple-400">Edit Note</h2>
      <input type="text" id="edit-title" placeholder="Note Title" class="w-full px-4 py-3 mb-4 rounded-lg bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500">
      <textarea id="edit-content" placeholder="Write your note here... (supports Markdown)" rows="10" class="w-full px-4 py-3 mb-4 rounded-lg bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500"></textarea>
      <input type="text" id="edit-tags" placeholder="Tags (e.g., work, ideas)" class="w-full px-4 py-3 mb-4 rounded-lg bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500">
      <div class="flex justify-end space-x-4">
        <button onclick="document.getElementById('edit-note-modal').classList.add('hidden')" class="px-6 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400">Cancel</button>
        <button id="save-edit-btn" class="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- History Modal -->
  <div id="history-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
      <div class="bg-white dark:bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-xl">
          <h2 class="text-2xl font-bold mb-4 text-purple-600 dark:text-purple-400">Version History</h2>
          <ul id="history-list" class="space-y-4"></ul>
          <div class="flex justify-end mt-4">
              <button onclick="document.getElementById('history-modal').classList.add('hidden')" class="px-6 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400">Close</button>
          </div>
      </div>
  </div>

<div class="absolute bottom-4 left-4 p-2 text-sm text-gray-500 dark:text-gray-400">
  <span id="theme-toggle" class="cursor-pointer">
    <i class="fas fa-sun hidden dark:inline-block"></i>
    <i class="fas fa-moon dark:hidden"></i>
  </span>
</div>
<script>
    document.getElementById('theme-toggle').addEventListener('click', () => {
      const isDark = document.documentElement.classList.toggle('dark');
      localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
    });
</script>
</body>
</html>
